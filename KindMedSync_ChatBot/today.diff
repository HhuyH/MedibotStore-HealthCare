diff --git a/KMS_ChatBot/Chatbot_BackEnd/prompts/__pycache__/prompts.cpython-313.pyc b/KMS_ChatBot/Chatbot_BackEnd/prompts/__pycache__/prompts.cpython-313.pyc
index 8988efd..d85e944 100644
Binary files a/KMS_ChatBot/Chatbot_BackEnd/prompts/__pycache__/prompts.cpython-313.pyc and b/KMS_ChatBot/Chatbot_BackEnd/prompts/__pycache__/prompts.cpython-313.pyc differ
diff --git a/KMS_ChatBot/Chatbot_BackEnd/prompts/prompts.py b/KMS_ChatBot/Chatbot_BackEnd/prompts/prompts.py
index 3c904e8..9cb383a 100644
--- a/KMS_ChatBot/Chatbot_BackEnd/prompts/prompts.py
+++ b/KMS_ChatBot/Chatbot_BackEnd/prompts/prompts.py
@@ -232,7 +232,7 @@ def build_KMS_prompt(
 
          ```json
          {{
-            "action": one of ["ask_symptom_intro", "followup", "related", "light_summary", "diagnosis"]
+            "action": one of ["followup", "related", "light_summary", "diagnosis", "post-diagnosis"]
             "message": "CÃ¢u tráº£ lá»i tá»± nhiÃªn báº±ng tiáº¿ng Viá»‡t",
             "updated_symptom": "Ho",
             "end": true | false
@@ -327,167 +327,95 @@ def build_KMS_prompt(
 
     """.strip()
     
-    # "ğŸ©º 1. Create follow up question for symptom" Táº¡o cÃ¢u há»i Ä‘á»ƒ há»i vá» chi tiáº¿t triá»‡u chá»©ng
-    prompt += f"""
-      ğŸ©º STEP â€” 1. Create follow up question for symptom
-
-      â— Follow-up symptom list (you may ask about **only these**):  
-      {json.dumps(symptoms_to_ask, ensure_ascii=False)}
-
-      ğŸ” Follow-up allowance:
-      - had_conclusion = {"true" if had_conclusion else "false"}
-
-      ğŸ›‘ Follow-up Policy:
-
-      You are ONLY allowed to set `"action": "followup"` if:
-      - `symptoms_to_ask` is not empty  
-      â†’ This is the ONLY condition for triggering follow-up.
-
-      ğŸš« In ALL other cases:
-      - You must SKIP STEP 1 entirely.
-      - Do NOT generate a follow-up question â€” even in reworded or softer form.
-      - Do NOT guess, infer, or rephrase questions for symptoms not explicitly listed.
-
-      Even if a symptom appears in `stored_symptoms_name`, you are NOT allowed to follow up unless:
-      - It is in `symptoms_to_ask`,  
-      - OR the user clearly revisits it after a previous conclusion.
-
-      This is a strict rule. Any violation is considered a logic failure.
-
-            
-      ğŸš« VERY IMPORTANT:
-         - If the user has ALREADY answered your previous follow-up â€” even in vague or brief form like:
-            â€¢ â€œTáº§m 5-10 phÃºtâ€
-            â€¢ â€œCÅ©ng nhanh thÃ´iâ€
-            â€¢ â€œCháº¯c vÃ i tiáº¿ngâ€
-            â€¢ â€œKhÃ´ng nhá»› rÃµ, cháº¯c khoáº£ng chiá»uâ€
-         â†’ then you must NOT ask about the same aspect again (e.g., duration, intensity).
-
-         - Do NOT reword or â€œdouble checkâ€ the same topic â€” it breaks the conversational flow.
-
-      Examples:
-         - Bot: â€œBáº¡n thÆ°á»ng bá»‹ Ä‘au Ä‘áº§u trong bao lÃ¢u?â€  
-         User: â€œTáº§m 5-10 phÃºtâ€  
-         â†’ âœ… User has answered â†’ SKIP follow-up on duration
-
-      ğŸ“Œ If the symptom has already been followed up and no new details are emerging from the user,  
-         â†’ you MUST NOT continue repeating similar follow-up questions.
-
-         In this case, you should either:
-         - Switch to `"related"` (if it hasn't been done), or  
-         - Proceed to `"light_summary"` if follow-up seems exhausted.
-
-         Do NOT ask variations of the same follow-up question unless the user introduced a new detail.
-
-      â†’ Then, write ONE fluent, empathetic question in **Vietnamese** to clarify whatâ€™s missing.
-
-      â†’ Your question should give the user multiple directions to reflect on, not just a single narrow angle.
-
-      â†’ Do NOT just ask â€œBáº¡n tháº¥y tháº¿ nÃ o?â€ â€” thatâ€™s too vague. Instead, offer some soft examples inside the question itself.
-
-      â†’ These gentle contrasts help users pick what feels right, without needing medical vocabulary.
-
-      âš ï¸ DO NOT:
-      - Use any symptom not listed in `symptoms_to_ask`
-      - Repeat questions the user already answered (even vaguely)
-      - Ask more than one question
-      - Mention possible diseases
-
-      Instructions:
-      - Only ask about **that one symptom** â€” do NOT bring up new or related symptoms.
-      - ğŸš« For example, if the symptom is â€œnhá»©c Ä‘áº§uâ€, you must NOT ask whether the user also feels â€œmá»‡t má»iâ€, â€œbuá»“n nÃ´nâ€, or any other symptom.
-      - ğŸš« You must also avoid phrases like:
-         â€¢ â€œCÃ³ kÃ¨m theo cáº£m giÃ¡câ€¦ khÃ´ng?â€
-         â€¢ â€œCÃ³ thÃªm triá»‡u chá»©ng gÃ¬ khÃ¡c khÃ´ng ha?â€
-      - âœ… These are part of STEP 2 (related symptoms) and must not appear during follow-up.
-         â†’ If you accidentally include related symptoms in your follow-up, the result will be rejected by the system.
-      - Do NOT repeat what the user already said (e.g., náº¿u há» nÃ³i â€œÄ‘au Ä‘áº§u tá»« sÃ¡ngâ€ thÃ¬ Ä‘á»«ng há»i láº¡i â€œbáº¡n Ä‘au tá»« khi nÃ o?â€).
-      - Instead, dig deeper:
-      - Timing (kÃ©o dÃ i bao lÃ¢u, xuáº¥t hiá»‡n khi nÃ o?)
-      - Severity (náº·ng dáº§n, thoÃ¡ng qua hay dai dáº³ng?)
-      - Triggers (xuáº¥t hiá»‡n khi lÃ m gÃ¬?)
-      - Functional impact (cáº£n trá»Ÿ sinh hoáº¡t khÃ´ng?)
+   # STEP 1 â€” Follow-up hoáº·c Skip náº¿u khÃ´ng Ä‘á»§ Ä‘iá»u kiá»‡n
+    if symptoms_to_ask:
+      prompt += f"""
+         ğŸ©º STEP â€” 1. Create Follow-Up Question
 
-      â†’ Follow the Global Tone Guide above
+         â— Symptom(s) available for follow-up:  
+         {json.dumps(symptoms_to_ask, ensure_ascii=False)}
 
-      ğŸ’¡ Before generating the follow-up, read `recent_user_messages` and `recent_assistant_messages` carefully.
-         â†’ If the assistant has already asked about this symptom â€” even with different wording â€” you must skip it.
+         ğŸ›‘ Follow-Up Policy:
+         If `symptoms_to_ask` is not empty â†’ you must enter follow-up mode first.
 
-      ğŸ”„ After finishing follow-up:
+         DO NOT skip to diagnosis unless all required follow-ups have been asked or clearly answered by user in free text.
 
-         You must now choose ONE of the following next steps based on the userâ€™s current information:
+         You are ONLY allowed to set `"action": "followup"` if:
+         - `symptoms_to_ask` is not empty  
+         â†’ This is the ONLY condition to trigger follow-up.
 
-         1. If symptoms are clear but you still want to enrich understanding â†’ choose `"related"`  
-            â†’ Ask about relevant symptoms that often co-occur.
+         Even if a symptom is in `stored_symptoms_name`, you are NOT allowed to follow up unless:
+         - It is in `symptoms_to_ask`,  
+         - OR the user clearly revisits it after a previous conclusion.
 
-         2. If symptoms are mild, temporary, and donâ€™t need further clarification â†’ choose `"light_summary"`  
-            â†’ Write a gentle summary and remind the user to keep monitoring.
-
-         3. If symptoms are clear and you can suggest possible causes â†’ choose `"diagnosis"`  
-            â†’ Write a friendly, informative explanation in Vietnamese.
-
-         â›” Do NOT continue looping or re-asking old questions.
-
-         âœ… Pick only ONE action from the list â€” never combine multiple.
+         This is a strict rule. Any violation is considered a logic failure.
 
+         ğŸš« DO NOT:
+         - Repeat questions already asked (even if vaguely answered, like â€œabout 5-10 minutesâ€, â€œI guess a few hoursâ€)
+         - Reword or â€œdouble checkâ€ the same topic
+         - Mention any related symptoms or diseases
+         - Ask more than one question
 
+         âœ… Your task:
+         - Write ONE empathetic, specific question in Vietnamese  
+         - Focus only on the single symptom in `symptoms_to_ask`  
+         - Use soft contrast options to help the user answer  
+         - Follow the **Global Tone Guide**
       """.strip()
-    
-    # "ğŸ§© 2. Create question for Related Symptoms" Há»i triá»‡u chá»©ng cÃ³ thá»ƒ liÃªn quan 
-    prompt += f"""   
-         ğŸ§© STEP â€” 2. Create question for Related Symptoms:
-
-         ğŸ›‘ STRICT RULE: Related symptoms may only be asked **once per conversation**.
+    else:
+      prompt += """
+         ğŸ©º STEP â€” 1. Skip Follow-Up
 
-         â†’ You are allowed to ask about related symptoms only if:
-         - The main symptoms have already been explored (follow-up is done or skipped)
-         - There is no related symptom question already present in `recent_assistant_messages`
+         ğŸš« There are no more symptoms to follow up, and the user is not revisiting a previous one.
 
-         âŒ If a related symptom question has already appeared â€” even with different words or softer phrasing â€” you MUST SKIP this step entirely.
+         You MUST skip this step entirely.
 
-         âœ… Do NOT attempt to â€œclarifyâ€, â€œsoftenâ€, or â€œrevisitâ€ related symptoms. Treat this as a strict one-time opportunity.
+         ğŸ‘‰ Choose ONE next step:
+         - `"related"` if applicable and not yet asked
+         - `"diagnosis"` if user has described â‰¥2 meaningful symptoms
+         - `"light_summary"` if symptoms seem mild or unclear
 
-         For example:
-           - If the assistant previously asked:  
-             â€œBáº¡n cÃ³ cáº£m tháº¥y hoa máº¯t, chÃ³ng máº·t gÃ¬ khÃ´ng?â€  
-           â†’ Then you MUST NOT ask again:  
-             â€œVáº­y cÃ²n chÃ³ng máº·t hay cáº£m giÃ¡c quay cuá»“ng gÃ¬ khÃ´ng?â€
-
-         â†’ Even if words differ, if the meaning is the same, it is considered a duplication.
-
-         âš ï¸ Once a related question has been asked, you must proceed to `"diagnosis"` or `"light_summary"` â€” depending on context.
-
-         â†’ If the user replies vaguely or says things like â€œkhÃ´ng cÃ³â€, â€œkhÃ´ng rÃµâ€, â€œcháº¯c khÃ´ng sao Ä‘Ã¢uâ€, etc.  
-         â†’ Then you must **not retry this step** â€” move forward instead.
-
-         ğŸ”’ If uncertain:
-         - Prefer `"diagnosis"` if the user has described â‰¥2 symptoms with meaningful details
-         - Otherwise, choose `"light_summary"` as a gentle closing step
+         âš ï¸ DO NOT:
+         - Retry follow-up
+         - Reword old questions
+         - Ask about additional symptoms â€” thatâ€™s in STEP 2
+      """.strip()
 
-         â• Example transitions (only if allowed):
-           - â€œMÃ¬nh há»i váº­y vÃ¬ Ä‘Ã´i khi má»‡t má»i kÃ©o dÃ i cÃ³ thá»ƒ Ä‘i kÃ¨m cÃ¡c triá»‡u chá»©ng nhÆ° váº­y.â€
-           - â€œThá»‰nh thoáº£ng nhá»¯ng cáº£m giÃ¡c nÃ y sáº½ Ä‘i cÃ¹ng vá»›i nhá»¯ng triá»‡u chá»©ng khÃ¡c ná»¯a Ä‘Ã³â€¦â€
+   # "ğŸ§© 2. Create question for Related Symptoms" Há»i triá»‡u chá»©ng cÃ³ thá»ƒ liÃªn quan 
+    if related_symptom_names:
+            prompt += f"""
+               ğŸ§© STEP â€” 2. Ask About Related Symptoms
 
-         â†’ Related symptoms to consider: {', '.join(related_symptom_names or [])}
+               set `"action": "related"`
 
-         ğŸš« FINAL WARNING:
+               ğŸ‘‰ You may now ask about **possibly related symptoms** to complete the context.
+               
+               âš ï¸ STRICT RULES:
+               - Only ask this once per session.
+               - Check that no similar question has already been asked.
+               - If any prior assistant message includes a prompt about â€œcáº£m giÃ¡c khÃ¡câ€, â€œtriá»‡u chá»©ng Ä‘i kÃ¨mâ€, etc â†’ you must skip.
 
-            If `recent_assistant_messages` contains **any sentence** that asks about related symptoms â€” even with different wording â€” you MUST SKIP this step completely.
+               â†’ Related symptoms to consider: {', '.join(related_symptom_names)}
 
-            â†’ This includes phrases like:
-            - â€œMÃ¬nh Ä‘ang nghÄ© khÃ´ng biáº¿t báº¡n cÃ³ thÃªm cáº£m giÃ¡c nÃ o khÃ¡câ€¦â€
-            - â€œÄÃ´i khi triá»‡u chá»©ng nÃ y Ä‘i kÃ¨mâ€¦â€
-            - â€œBáº¡n cÃ³ tháº¥y thÃªm gÃ¬ nhÆ° chÃ³ng máº·t, hoa máº¯t khÃ´ngâ€¦â€
+               ğŸ¯ Write one natural follow-up message in Vietnamese that gently brings up these related symptoms.
+                  â†’ Follow the Global Tone Guide above
+                  
+               âŒ Do not repeat, clarify, or revisit this once itâ€™s been asked.
+            """.strip()
+    else:
+         prompt += """
+            ğŸ§© STEP â€” 2. Skip Related Symptoms
 
-            â— Repeating or rephrasing a related symptom prompt â€” even once â€” is a **critical logic violation**.
+            ğŸ” There are no related symptoms to ask, or they have already been covered.
 
-            âš ï¸ The system will reject your response and consider the assistant broken.
+            ğŸ‘‰ You must now **proceed directly** to the next logical step.
 
-            â†’ Never attempt to "soften", "clarify", or "extend" a related question after it has already appeared.
+            â†’ If the user has described **2 or more meaningful symptoms**, move to `"diagnosis"`.
 
-            â†’ This is an **absolute rule** â€” no exceptions.
+            â†’ Otherwise, use `"light_summary"` to gently summarize and transition out.
 
-    """.strip()
+            âš ï¸ Do not retry any previous step. Move forward.
+         """.strip()
 
     # "3. ğŸŒ¿ Light Summary" â€” Táº¡o pháº£n há»“i nháº¹ nhÃ ng khi khÃ´ng cáº§n cháº©n Ä‘oÃ¡n hoáº·c follow-up thÃªm
     prompt += f"""   
@@ -651,82 +579,79 @@ def build_KMS_prompt(
                      â†’ This score reflects AI reasoning â€” NOT a medical diagnosis.
     """.strip()
     
-    # "ğŸ†• STEP â€” 5. Detect and Handle Updated Symptom" - xÃ¡c Ä‘á»‹nh ngÆ°á»i dÃ¹ng Ä‘ang nÃ³i Ä‘áº¿n triá»‡u chá»©ng cÅ© vÃ  update
-    prompt += f"""
-      ğŸ†• STEP â€” 5. Detect and Handle Updated Symptom
-
-         Your job in this step is to determine whether the user is describing a **change, progression, or additional detail** for a symptom they previously mentioned.
-
-         This is called an â€œupdated symptomâ€.
+    # "ğŸ†• STEP â€” 5. Post-Diagnosis Updated Symptom (if had_conclusion = true)"
+    if had_conclusion and (not symptoms_to_ask) and (not related_symptom_names):
+      prompt += f"""
+      ğŸ†• STEP â€” 5. Post-Diagnosis Updated Symptom
 
-         âš ï¸ Do NOT set `"updated_symptom"` in the following cases:
+      Your job in this step is to determine whether the user is describing a **change, progression, or additional detail** for a symptom they previously mentioned.
 
-         1. The user only uses vague or uncertain expressions such as:
-            - â€œhÃ¬nh nhÆ°â€, â€œcÃ³ váº»â€, â€œcháº¯c lÃ â€, â€œmÃ¬nh nghÄ©â€, â€œkhÃ´ng rÃµâ€, â€œcÃ³ thá»ƒâ€  
-            â†’ and all similar expressions of approximation or uncertainty.
+      set `"action": "post-diagnosis"`
 
-         2. The user merely repeats or rementions the symptom (e.g., â€œmÃ¬nh váº«n chÃ³ng máº·tâ€), **without adding new descriptive details**.
+      ---
 
-         3. The assistant is the one asking about the symptom (e.g., follow-up question), and the user has **not yet replied**.  
-            â†’ Do **NOT** assume an update just because the symptom was mentioned in the assistantâ€™s message.
+      ğŸ” You must carefully scan:
+      - `recent_user_messages`: to detect any new descriptive information
+      - `stored_symptoms_name`: to match it to a known symptom
 
-         ---
+      This step applies in both of the following cases:
+      - The user adds more detail **after** a diagnosis (`had_conclusion = true`)
 
-         âœ… You may set `"updated_symptom"` **only if** the user **voluntarily** provides **concrete new details** (not just repeats, and not in response to a follow-up).
+      ---
 
-         These new details must describe a **change, progression, or additional context** related to a previously reported symptom â€” such as timing, intensity, duration, or characteristics.
+      ğŸš« DO NOT set `"updated_symptom"` in the following cases:
+      - The user uses vague or uncertain expressions like â€œhÃ¬nh nhÆ°â€, â€œcÃ³ váº»â€, â€œcháº¯c lÃ â€, â€œkhÃ´ng rÃµâ€
+      - The user repeats the symptom without adding new information
+      - The assistant is the one asking, and the user hasnâ€™t responded yet
 
-         This is valid only if:
-         - The message contains clear comparative or descriptive information  
-         - AND `stored_symptoms_name` includes that symptom  
-         - AND the user is **not introducing a new symptom**
+      ---
 
-         Examples of valid updates:
-         - â€œHÃ´m nay tháº¥y chÃ³ng máº·t kÃ©o dÃ i hÆ¡nâ€ â†’ update to â€œChÃ³ng máº·tâ€
-         - â€œGiá» thÃ¬ cáº£m giÃ¡c Ä‘Ã³ quay cuá»“ng luÃ´n rá»“iâ€ â†’ update to â€œChÃ³ng máº·tâ€
-         - â€œLáº§n nÃ y Ä‘au Ä‘áº§u kiá»ƒu khÃ¡c lÃºc trÆ°á»›câ€ â†’ update to â€œÄau Ä‘áº§uâ€
-         - â€œGiá» thÃ¬ sá»• mÅ©i cÃ³ Ä‘Ã m mÃ u xanh rá»“iâ€ â†’ update to â€œSá»• mÅ©iâ€
+      âœ… You may set `"updated_symptom": "<name>"` **only if**:
+      - The user voluntarily provides new, descriptive info (not prompted)
+      - It describes timing, intensity, duration, or other characteristics
+      - The symptom exists in `stored_symptoms_name`
 
-         If you detect such an update:
-         â†’ Set `"updated_symptom": "TÃªn triá»‡u chá»©ng"`  
-         â†’ Also embed a soft acknowledgment in your `"message"` to reflect that you recognized this change (e.g., â€œMÃ¬nh ghi nháº­n thÃªm rá»“i nÃ¨â€).
+      Examples of valid updates:
+      - â€œHÃ´m nay tháº¥y chÃ³ng máº·t kÃ©o dÃ i hÆ¡nâ€ â†’ update to â€œChÃ³ng máº·tâ€
+      - â€œLáº§n nÃ y Ä‘au Ä‘áº§u kiá»ƒu khÃ¡c lÃºc trÆ°á»›câ€ â†’ update to â€œÄau Ä‘áº§uâ€
+      - â€œGiá» thÃ¬ sá»• mÅ©i cÃ³ Ä‘Ã m mÃ u xanh rá»“iâ€ â†’ update to â€œSá»• mÅ©iâ€
 
-         ---
+      ---
 
-         âœ… Good response examples (you can take inspiration from these, but do not reuse them exactly):
+      ğŸ¯ Response logic:
 
-         - â€œÃ€ MÃ¬nh tháº¥y triá»‡u chá»©ng Ä‘Ã³ cÃ³ váº» thay Ä‘á»•i chÃºt rá»“i ha.â€
-         - â€œUm, cáº£m Æ¡n báº¡n nha. Nghe nhÆ° lÃ  tÃ¬nh tráº¡ng Ä‘Ã³ Ä‘ang tiáº¿n triá»ƒn thÃªm chÃºt rá»“i Ã¡.â€
-         - â€œMÃ¬nh ghi nháº­n thÃ´ng tin báº¡n vá»«a chia sáº» nha, Ä‘á»ƒ theo dÃµi ká»¹ hÆ¡n hen.â€
-         - â€œHiá»ƒu rá»“i, cÃ³ váº» nhÆ° triá»‡u chá»©ng nÃ y Ä‘ang khÃ¡c hÆ¡n chÃºt so vá»›i lÃºc trÆ°á»›c ha.â€
-         - â€œBáº¡n mÃ´ táº£ thÃªm rÃµ hÆ¡n rá»“i, mÃ¬nh sáº½ lÆ°u láº¡i Ä‘á»ƒ xem xÃ©t cáº©n tháº­n hÆ¡n ná»¯a nha.â€
+      â†’ Always embed a soft acknowledgment in your `"message"` when setting `"updated_symptom"`
 
-         ğŸ‘‰ These are just reference styles â€” make your response feel like a gentle conversation, not a script.
+      âœ… Example acknowledgments (rephrase freely, but keep the warm tone):
+      - â€œÃ€, cÃ³ váº» nhÆ° triá»‡u chá»©ng Ä‘Ã³ Ä‘ang náº·ng hÆ¡n chÃºt rá»“i haâ€¦â€
+      - â€œHiá»ƒu rá»“i nhen, láº§n nÃ y cáº£m giÃ¡c Ä‘Ã³ nghe cÃ³ váº» khÃ¡c hÆ¡n trÆ°á»›c Ã¡.â€
+      - â€œCáº£m Æ¡n báº¡n, mÃ¬nh sáº½ ghi chÃº thÃªm Ä‘á»ƒ theo dÃµi ká»¹ hÆ¡n nha.â€
+      - â€œMÃ¬nh tháº¥y báº¡n mÃ´ táº£ rÃµ hÆ¡n rá»“i, Ä‘á»ƒ mÃ¬nh lÆ°u láº¡i thÃªm nghen.â€
+      - â€œMÃ¬nh ghi nháº­n thÃ´ng tin báº¡n vá»«a chia sáº» nha, Ä‘á»ƒ theo dÃµi sÃ¡t hÆ¡n ha.â€
 
+      â†’ Follow the **Global Tone Guide**.
 
-         ---
+      ---
 
+      âš–ï¸ Action logic:
 
-         âš–ï¸ Choose the right action:
+      - If `had_conclusion = true`:
+         â†’ Set `"action": "post-diagnosis"`  
+         â†’ Then choose either `"light_summary"` or `"diagnosis"` as the next step depending on severity
 
-         - If the update sounds **mild or non-concerning** â†’ set `action = "light_summary"`
-         - If the update clearly suggests a **specific condition** or raises concern  
-            (e.g., mÃ¡u, tÃ­m, liá»‡t, báº¥t thÆ°á»ng náº·ng) â†’ set `action = "diagnosis"`
+      - If `had_conclusion = false`:
+         â†’ Do NOT set `"post-diagnosis"`
+         â†’ Choose `"light_summary"` if mild  
+         â†’ Choose `"diagnosis"` if the detail adds meaningful insight
 
-         âœ… Do NOT use "related" unless you are also asking about other symptoms.
-         âŒ Do NOT reuse old questions.
-
-         ---
-
-         ğŸ“Œ Summary:
-
-         - Always set `"updated_symptom"` if relevant.
-         - Choose between `"light_summary"` or `"diagnosis"` depending on severity.
-         - Only escalate to `"diagnosis"` if the new info is potentially medically significant
+      ---
 
+      ğŸ“Œ Summary:
+      - Always set `"updated_symptom"` if appropriate
+      - Embed a gentle, human message
+      - Route accordingly using `"light_summary"` or `"diagnosis"`
+      """.strip()
 
-    """
-   
     # Rule set action
     prompt += f"""
 
diff --git a/KMS_ChatBot/Chatbot_BackEnd/routes/__pycache__/chat.cpython-313.pyc b/KMS_ChatBot/Chatbot_BackEnd/routes/__pycache__/chat.cpython-313.pyc
index f0cb50f..ece0330 100644
Binary files a/KMS_ChatBot/Chatbot_BackEnd/routes/__pycache__/chat.cpython-313.pyc and b/KMS_ChatBot/Chatbot_BackEnd/routes/__pycache__/chat.cpython-313.pyc differ
diff --git a/KMS_ChatBot/Chatbot_BackEnd/routes/chat.py b/KMS_ChatBot/Chatbot_BackEnd/routes/chat.py
index ccf7706..f21179c 100644
--- a/KMS_ChatBot/Chatbot_BackEnd/routes/chat.py
+++ b/KMS_ChatBot/Chatbot_BackEnd/routes/chat.py
@@ -5,6 +5,10 @@ import asyncio
 import logging
 logger = logging.getLogger(__name__)
 from datetime import datetime
+from redis import asyncio as aioredis
+
+# Táº¡o client náº¿u cáº§n
+redis_client = aioredis.from_url("redis://localhost")
 
 from models import Message,ResetRequest
 from config.intents import INTENT_PIPELINES
@@ -12,12 +16,14 @@ from config.intents import INTENT_PIPELINES
 from utils.limit_history import limit_history_by_tokens, refresh_system_context
 from utils.auth_utils import has_permission, normalize_role
 from utils.session_store import (
+    resolve_session_key,
     get_session_data, 
     save_session_data, 
     get_symptoms_from_session, 
     clear_followup_asked_all_keys, 
     clear_symptoms_all_keys,
-    update_chat_history_in_session
+    update_chat_history_in_session,
+    reset_related_symptom_flag
 )
 from utils.intent_utils import detect_intent, build_system_message
 from utils.symptom_utils import (
@@ -48,7 +54,7 @@ symptom_list = get_symptom_list()
 async def chat_stream(msg: Message = Body(...)):
     role = normalize_role(msg.role)
     # logger.info(f"ID: {msg.user_id} User: ({msg.username}) Session:({msg.session_id}) vá»›i vai trÃ² {role} gá»­i: {msg.message}")
-    logger.info(f"ğŸ“¨ Nháº­n tin User: {msg.user_id} || Role: {role}")
+    logger.info(f"ğŸ“¨ Nháº­n tin User: {msg.user_id} || Role: {role} || Role: {msg.message}")
     if not has_permission(role, "chat"):
         async def denied_stream():
             yield "data: âš ï¸ Báº¡n khÃ´ng Ä‘Æ°á»£c phÃ©p thá»±c hiá»‡n chá»©c nÄƒng nÃ y.\n\n"
@@ -81,7 +87,7 @@ async def chat_stream(msg: Message = Body(...)):
     
     is_same_day = session_data.get("active_date") == today
     diagnosed_today = has_diagnosis_today(user_id=msg.user_id) if msg.user_id else False
-
+    
     # Sau khi bot xá»­ lÃ½ xong vÃ  Ä‘Ã£ cÃ³ cÃ¢u tráº£ lá»i cuá»‘i cÃ¹ng:
 
     recent_messages = session_data.get("recent_messages", [])
@@ -97,11 +103,11 @@ async def chat_stream(msg: Message = Body(...)):
     intent = await detect_intent(
         last_intent=last_intent,
         recent_user_messages=recent_user_messages,
-        recent_assistant_messages=recent_assistant_messages
+        recent_assistant_messages=recent_assistant_messages,
+        diagnosed_today=diagnosed_today
     )
 
     session_data["last_intent"] = intent
-    save_session_data(msg.session_id, session_data)
 
     # XÃ¡c Ä‘á»‹nh má»¥c tiÃªu ngÆ°á»i dÃ¹ng Ä‘á»ƒ láº¥y chá»©c nÄƒng phÃ¹ há»£p
     intent = intent.replace("intent:", "").strip()
@@ -118,6 +124,7 @@ async def chat_stream(msg: Message = Body(...)):
         buffer = ""
         is_json_mode = True
         final_bot_message = ""
+        chat_id = None
         nonlocal symptoms, suggestion, updated_session_data, session_data
         sql_query = None
         natural_text = ""
@@ -154,13 +161,17 @@ async def chat_stream(msg: Message = Body(...)):
                             yield f"data: {json.dumps({'natural_text': content})}\n\n"
                             await asyncio.sleep(0.01)
                 final_bot_message = buffer.strip()
-                update_chat_history_in_session(session_data, msg.session_id, msg.message, final_bot_message)
+
+                # âœ… Reload session sau khi health_talk Ä‘Ã£ cáº­p nháº­t báº±ng mark_followup_asked, update_note, v.v.
+                session_data = await get_session_data(user_id=msg.user_id, session_id=msg.session_id)
+                updated_session_data = session_data
+
+                update_chat_history_in_session(msg.user_id, session_data, msg.session_id, msg.message, final_bot_message)
 
                 # âœ… LÆ°u log há»™i thoáº¡i
                 save_chat_log(user_id=msg.user_id, guest_id=None, intent=intent, message=msg.message, sender='user')
                 chat_id = save_chat_log(user_id=msg.user_id, guest_id=None, intent=intent, message=final_bot_message, sender='bot')
-
-                
+   
             # --- Step 2: GPT Ä‘iá»u phá»‘i health_talk ---
             elif step == "health_talk":
                 chunks = []
@@ -187,7 +198,11 @@ async def chat_stream(msg: Message = Body(...)):
                 final_message = full_message
                 final_bot_message = final_message
 
-                update_chat_history_in_session(session_data, msg.session_id, msg.message, final_bot_message)
+                # âœ… Reload session sau khi health_talk Ä‘Ã£ cáº­p nháº­t báº±ng mark_followup_asked, update_note, v.v.
+                session_data = await get_session_data(user_id=msg.user_id, session_id=msg.session_id)
+                updated_session_data = session_data
+
+                await update_chat_history_in_session(msg.user_id, session_data, msg.session_id, msg.message, final_bot_message)
 
                 # âœ… LÆ°u log há»™i thoáº¡i
                 save_chat_log(user_id=msg.user_id, guest_id=None, intent=intent, message=msg.message, sender='user')
@@ -195,7 +210,6 @@ async def chat_stream(msg: Message = Body(...)):
 
                 # âœ… LÆ°u message cuá»‘i cá»§a bot
                 session_data["last_bot_message"] = final_message
-                save_session_data(msg.session_id, session_data)
 
                 yield "data: [DONE]\n\n"
                 return
@@ -215,13 +229,17 @@ async def chat_stream(msg: Message = Body(...)):
                 final_message = "".join(chunks).strip()
                 final_bot_message = final_message
 
-                update_chat_history_in_session(session_data, msg.session_id, msg.message, final_bot_message)
+                # âœ… Reload session sau khi health_talk Ä‘Ã£ cáº­p nháº­t báº±ng mark_followup_asked, update_note, v.v.
+                session_data = await get_session_data(user_id=msg.user_id, session_id=msg.session_id)
+                updated_session_data = session_data
+
+                await update_chat_history_in_session(msg.user_id, session_data, msg.session_id, msg.message, final_bot_message)
+
                 # âœ… LÆ°u log há»™i thoáº¡i
                 save_chat_log(user_id=msg.user_id, guest_id=None, intent=intent, message=msg.message, sender='user')
                 chat_id = save_chat_log(user_id=msg.user_id, guest_id=None, intent=intent, message=final_bot_message, sender='bot')
 
                 session_data["last_bot_message"] = final_message
-                save_session_data(msg.session_id, session_data)
 
                 yield "data: [DONE]\n\n"
                 return
@@ -237,7 +255,7 @@ async def chat_stream(msg: Message = Body(...)):
                     if info and info.get("user_id"):
                         user_id_for_summary = info["user_id"]
                         session_data["current_summary_user_id"] = user_id_for_summary
-                        save_session_data(msg.session_id, session_data)
+                        await save_session_data(user_id=msg.user_id, session_id=msg.session_id, data=session_data)
                     else:
                         if info and info.get("ambiguous"):
                             match_type = info.get("matched_by")
@@ -267,7 +285,13 @@ async def chat_stream(msg: Message = Body(...)):
                 summary_data = result["summary_data"]
 
                 final_bot_message = markdown
-                update_chat_history_in_session(session_data, msg.session_id, msg.message, final_bot_message)
+
+                # âœ… Reload session sau khi health_talk Ä‘Ã£ cáº­p nháº­t báº±ng mark_followup_asked, update_note, v.v.
+                session_data = await get_session_data(user_id=msg.user_id, session_id=msg.session_id)
+                updated_session_data = session_data
+
+                await update_chat_history_in_session(msg.user_id, session_data, msg.session_id, msg.message, final_bot_message)
+                
                 # âœ… LÆ°u log há»™i thoáº¡i
                 save_chat_log(user_id=msg.user_id, guest_id=None, intent=intent, message=msg.message, sender='user')
                 chat_id = save_chat_log(user_id=msg.user_id, guest_id=None, intent=intent, message=final_bot_message, sender='bot')
@@ -333,32 +357,40 @@ async def chat_stream(msg: Message = Body(...)):
                 yield "data: [DONE]\n\n"
 
         # âœ… LÆ°u session náº¿u cÃ³ cáº­p nháº­t
-        if updated_session_data:
-            save_session_data(msg.session_id, updated_session_data)
+        # if updated_session_data:
+        #     await save_session_data(user_id=msg.user_id, session_id=msg.session_id, data=updated_session_data)
 
         yield "data: [DONE]\n\n"
-    
-    save_session_data(msg.session_id, session_data)
     return StreamingResponse(event_generator(), media_type="text/event-stream; charset=utf-8")
 
-
 @router.post("/chat/reset")
 async def reset_session(data: ResetRequest):
     session_id = data.session_id
     user_id = data.user_id
 
     # ğŸ” Reset toÃ n bá»™ session RAM (session_store)
-    save_session_data(session_id, {
-        "last_intent": None,
-        "recent_messages": [],
-        "symptoms": [],
-        "followup_asked": [],
-        "symptom_notes": []
-    })
+    await save_session_data(
+        user_id=user_id,
+        session_id=session_id,
+        data={
+            "last_intent": None,
+            "recent_messages": [],
+            "recent_user_messages": [],
+            "recent_assistant_messages": [],
+            "symptoms": [],
+            "followup_asked": [],
+            "symptom_notes_list": [],
+            "related_symptom_asked": False
+        }
+    )
 
     # ğŸ§¹ Reset luÃ´n bá»™ nhá»› symptom riÃªng náº¿u cÃ³
     await clear_symptoms_all_keys(user_id=user_id, session_id=session_id)
     await clear_followup_asked_all_keys(user_id=user_id, session_id=session_id)
+    await reset_related_symptom_flag(session_id=session_id, user_id=user_id)
+
+    await redis_client.delete(resolve_session_key(user_id, session_id))
+
 
     # logger.info(f"âœ… ÄÃ£ reset session cho user_id={user_id}, session_id={session_id}")
     logger.debug(await get_session_data(user_id, session_id))  # Log láº¡i Ä‘á»ƒ xÃ¡c nháº­n
@@ -373,24 +405,40 @@ async def get_chat_history(session_id: str, user_id: int = None):
     }
 
 @router.get("/chat/logs")
-def get_chat_logs(user_id: int = None, guest_id: int = None):
+def get_chat_logs(session_id: str = None, user_id: int = None, guest_id: int = None, limit: int = 30):
     import pymysql
     from config.config import DB_CONFIG
 
     conn = pymysql.connect(**DB_CONFIG)
     try:
         with conn.cursor() as cursor:
-            cursor.execute("""
-                SELECT message, sender, sent_at
-                FROM chat_logs
-                WHERE user_id = %s OR guest_id = %s
-                ORDER BY sent_at ASC
-            """, (user_id, guest_id))
-            rows = cursor.fetchall()
+            if user_id:
+                cursor.execute("""
+                    SELECT message, sender, sent_at
+                    FROM chat_logs
+                    WHERE user_id = %s
+                    ORDER BY sent_at DESC
+                    LIMIT %s
+                """, (user_id, limit))
+            elif guest_id:
+                cursor.execute("""
+                    SELECT message, sender, sent_at
+                    FROM chat_logs
+                    WHERE guest_id = %s
+                    ORDER BY sent_at DESC
+                    LIMIT %s
+                """, (guest_id, limit))
+            else:
+                return []
+
+            rows = list(cursor.fetchall())   # âœ… Chuyá»ƒn thÃ nh list
+            rows.reverse()                   # âœ… Äáº£o chiá»u Ä‘á»ƒ hiá»‡n tá»« cÅ© â†’ má»›i
+
             return [{"message": m, "sender": s, "time": str(t)} for m, s, t in rows]
     finally:
         conn.close()
 
+
 def save_chat_log(user_id=None, guest_id=None, intent=None, message=None, sender='user'):
     conn = pymysql.connect(**DB_CONFIG)
     try:
diff --git a/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/health_care.cpython-313.pyc b/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/health_care.cpython-313.pyc
index 7a6e9d1..71c9e58 100644
Binary files a/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/health_care.cpython-313.pyc and b/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/health_care.cpython-313.pyc differ
diff --git a/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/intent_utils.cpython-313.pyc b/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/intent_utils.cpython-313.pyc
index 0e01faa..13e77dd 100644
Binary files a/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/intent_utils.cpython-313.pyc and b/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/intent_utils.cpython-313.pyc differ
diff --git a/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/session_store.cpython-313.pyc b/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/session_store.cpython-313.pyc
index 3a7d900..ee4a3f0 100644
Binary files a/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/session_store.cpython-313.pyc and b/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/session_store.cpython-313.pyc differ
diff --git a/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/symptom_utils.cpython-313.pyc b/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/symptom_utils.cpython-313.pyc
index 4dfb864..721f98d 100644
Binary files a/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/symptom_utils.cpython-313.pyc and b/KMS_ChatBot/Chatbot_BackEnd/utils/__pycache__/symptom_utils.cpython-313.pyc differ
diff --git a/KMS_ChatBot/Chatbot_BackEnd/utils/health_care.py b/KMS_ChatBot/Chatbot_BackEnd/utils/health_care.py
index d0fda0b..4bfd8e8 100644
--- a/KMS_ChatBot/Chatbot_BackEnd/utils/health_care.py
+++ b/KMS_ChatBot/Chatbot_BackEnd/utils/health_care.py
@@ -25,7 +25,8 @@ from utils.session_store import (
     update_symptom_note_in_session, 
     save_session_data, get_session_data, 
     get_followed_up_symptom_ids, mark_followup_asked, 
-    save_symptoms_to_session, get_symptoms_from_session
+    save_symptoms_to_session, get_symptoms_from_session,
+    mark_related_symptom_asked
 )
 def extract_json(content: str) -> str:
     """
@@ -47,12 +48,13 @@ async def health_talk(
     session_context: dict = None
 ):
     session_data = await get_session_data(user_id=user_id, session_id=session_id)
-    followup_after_conclusion_used = session_data.get("followup_after_conclusion_used", False)
+    logger.debug("ğŸ“¦ Session ban Ä‘áº§u:\n%s", json.dumps(session_data, indent=2, ensure_ascii=False))
 
     # Step 1: TrÃ­ch triá»‡u chá»©ng má»›i
     new_symptoms, fallback_message = extract_symptoms_gpt(
         user_message,
-        recent_messages=recent_messages
+        recent_messages=recent_messages,
+        recent_assistant_messages=recent_assistant_messages
     )
     logger.info("ğŸŒ¿ Triá»‡u chá»©ng trÃ­ch Ä‘Æ°á»£c: %s", new_symptoms)
 
@@ -68,14 +70,11 @@ async def health_talk(
 
     # âœ… In log triá»‡u chá»©ng Ä‘Ã£ há»i follow-up
     asked = await get_followed_up_symptom_ids(session_id=session_id, user_id=user_id)
-    logger.info("ğŸ“Œ ÄÃ£ há»i follow-up cÃ¡c triá»‡u chá»©ng cÃ³ ID: %s", asked)
+    logger.info("ğŸ“ Follow-up IDs tá»« session: %s", asked)
 
-    session_data = await get_session_data(user_id=user_id, session_id=session_id)
 
-    had_conclusion = (
-        session_data.get("had_conclusion", False)
-        and not followup_after_conclusion_used
-    )
+
+    had_conclusion = session_data.get("had_conclusion", False)
 
     # Step 3: XÃ¢y prompt tá»•ng há»£p
     prompt = build_KMS_prompt(
@@ -90,6 +89,10 @@ async def health_talk(
         had_conclusion=had_conclusion
     )
 
+    # ğŸ”’ ÄÃ¡nh dáº¥u Ä‘Ã£ há»i related symptom (chá»‰ 1 láº§n duy nháº¥t)
+    if inputs.get("related_symptom_names"):
+        await mark_related_symptom_asked(session_id=session_id, user_id=user_id)
+        session_data = await get_session_data(user_id=user_id, session_id=session_id)
 
     # Step 4: Gá»i GPT (non-stream)
     completion = chat_completion(messages=[{"role": "user", "content": prompt}], temperature=0.7)
@@ -113,17 +116,9 @@ async def health_talk(
 
     action = parsed.get("action")
 
-    # Äáº·t cá» khi Ä‘Ã£ qua káº¿t luáº­n 1 láº§n Ä‘á»ƒ kiá»ƒm soÃ¡t followup
-    if action in ["light_summary", "diagnosis"]:
+    # âœ… Ghi nháº­n káº¿t luáº­n Ä‘á»ƒ Ä‘Ã¡nh dáº¥u Ä‘Ã£ cháº©n Ä‘oÃ¡n hÃ´m nay
+    if action == "diagnosis":
         session_data["had_conclusion"] = True
-        save_session_data(user_id=user_id, session_id=session_id, data=session_data)
-
-    if parsed.get("action") == "followup" and had_conclusion:
-        logger.info("ğŸ” ÄÃ£ cho phÃ©p follow-up sau káº¿t luáº­n. Táº¯t cá» had_conclusion.")
-        session_data["had_conclusion"] = False
-        session_data["followup_after_conclusion_used"] = True  # âœ… ÄÃ¡nh dáº¥u Ä‘Ã£ dÃ¹ng rá»“i
-        save_session_data(user_id=user_id, session_id=session_id, data=session_data)
-
 
     # ğŸ”„ Náº¿u ngÆ°á»i dÃ¹ng nÃ³i thÃªm vá» triá»‡u chá»©ng cÅ© â†’ ghi chÃº láº¡i vÃ o user_symptom_history
     updated_symptom = parsed.get("updated_symptom")
@@ -147,34 +142,59 @@ async def health_talk(
     # Äáº·t cÆ¡ cho nhá»¯ng triá»‡u chá»©ng tÆ°Æ¡ng á»©ng khi followup Ä‘Ã£ há»i
     if action == "followup" and target_followup_id:
         logger.info("âœ… ÄÃ¡nh dáº¥u Ä‘Ã£ há»i follow-up triá»‡u chá»©ng ID: %s", target_followup_id)
-        await mark_followup_asked(session_id, user_id, [target_followup_id])
+        await mark_followup_asked(user_id, session_id, [target_followup_id])
+        session_data = await get_session_data(user_id=user_id, session_id=session_id)
+        # logger.info("âœ… Session sau khi Ä‘Ã¡nh dáº¥u follow-up:\n%s", json.dumps(session_data, indent=2, ensure_ascii=False))
+
 
     end = parsed.get("end", False)
 
     # Log cÃ¡c biáº¿n phá»¥ trá»£
     logger.info("ğŸ¯ Action: %s", action)
 
+    # Náº¿u khÃ´ng cÃ³ cháº©n Ä‘oÃ¡n trÆ°á»›c Ä‘Ã³ trong ngÃ y thÃ¬ sáº½ táº¡o note dá»±a theo triá»‡u chá»©ng
+    if not diagnosed_today:
+        # ğŸ“‹ Táº¡o note
+        # Step 1: láº¥y note cÅ© tá»« session
+        existing_notes = session_data.get("symptom_notes_list", [])
+
+        # Step 2: gá»i GPT Ä‘á»ƒ láº¥y note má»›i (cÃ³ thá»ƒ chá»‰ 1-2 cÃ¡i)
+        new_notes = await generate_symptom_note(
+            symptoms=stored_symptoms,
+            recent_messages=recent_messages,
+            existing_notes=existing_notes
+        )
+
+        # Step 3: gá»™p láº¡i (override náº¿u cÃ³ id trÃ¹ng)
+        note_map = {n["id"]: n for n in existing_notes}
+        for n in new_notes:
+            note_map[n["id"]] = n  # override or add
+
+        symptom_notes_list = list(note_map.values())
+
+        # logger.debug("ğŸ“‹ Updated symptom_notes_list:\n%s", json.dumps(symptom_notes_list, indent=2, ensure_ascii=False))
+
+
+        # Step 4: lÆ°u vÃ o session
+        session_data["symptom_notes_list"] = symptom_notes_list
+        await save_session_data(user_id=user_id, session_id=session_id, data=session_data)
 
 
     if action == "diagnosis":
-        # âœ… LÆ°u triá»‡u chá»©ng má»›i náº¿u cÃ³
-        saved_ids = get_saved_symptom_ids(user_id)
-
-        # Gá»™p ID vÃ  note tá»« GPT
-        symptom_notes_list = await generate_symptom_note(stored_symptoms, recent_messages)
-
-        symptoms_to_save = []
-        for s in stored_symptoms:
-            if s["id"] not in saved_ids:
-                matching = next((item for item in symptom_notes_list if item["name"] == s["name"]), None)
-                symptoms_to_save.append({
-                    "id": s["id"],
-                    "note": matching["note"] if matching else "NgÆ°á»i dÃ¹ng Ä‘Ã£ mÃ´ táº£ má»™t sá»‘ triá»‡u chá»©ng trong cuá»™c trÃ² chuyá»‡n."
-                })
+        
+        #LÆ°u note Ä‘Ã£ Ä‘Æ°á»£c táº¡o trÆ°á»›c Ä‘Ã³ vÃ o db
+        if not diagnosed_today:
+            # âœ… LÆ°u triá»‡u chá»©ng má»›i náº¿u cÃ³
+            saved_ids = get_saved_symptom_ids(user_id)
 
-        if symptoms_to_save:
-            save_symptoms_to_db(user_id=user_id, symptoms=symptoms_to_save)
+            symptoms_to_save = [
+                {"id": note["id"], "note": note["note"]}
+                for note in symptom_notes_list
+                if note["id"] not in saved_ids
+            ]
 
+            if symptoms_to_save:
+                save_symptoms_to_db(user_id=user_id, symptoms=symptoms_to_save)
 
         # âœ… Xá»­ lÃ½ pháº§n bá»‡nh
         diseases = parsed.get("diseases", [])
@@ -266,21 +286,23 @@ async def decide_KMS_prompt_inputs(session_id: str, user_id: int):
     next_symptom = await get_next_symptom_to_followup(session_id, user_id, stored_symptoms)
 
     symptoms_to_ask = [next_symptom["name"]] if next_symptom else []
+    related_symptom_names = None  # âœ… Khá»Ÿi táº¡o máº·c Ä‘á»‹nh
 
     logger.info("ğŸ“­ symptoms_to_ask: %s", symptoms_to_ask)
 
-    related_symptom_names = []
-
-    symptom_ids = [s['id'] for s in stored_symptoms]
-    related = get_related_symptoms_by_disease(symptom_ids)
-    stored_names = [s["name"] for s in stored_symptoms]
-    related_names = [s["name"] for s in related if s["name"] not in stored_names]
-    related_symptom_names = list(set(related_names))[:10]
+    if not symptoms_to_ask:
+        session = await get_session_data(session_id=session_id, user_id=user_id)
+        if not session.get("related_symptom_asked"):
+            symptom_ids = [s['id'] for s in stored_symptoms]
+            related = get_related_symptoms_by_disease(symptom_ids)
+            stored_names = [s["name"] for s in stored_symptoms]
+            related_names = [s["name"] for s in related if s["name"] not in stored_names]
+            related_symptom_names = list(set(related_names))[:10] or None  # None náº¿u khÃ´ng cÃ²n
 
     return {
         "symptoms_to_ask": symptoms_to_ask,
-        "raw_followup_question": None,  # khÃ´ng dÃ¹ng ná»¯a
-        "related_symptom_names": related_symptom_names or None,
+        "raw_followup_question": None,
+        "related_symptom_names": related_symptom_names,
         "target_followup_id": next_symptom["id"] if next_symptom else None
     }
 
@@ -486,8 +508,6 @@ def filter_new_predicted_diseases(cursor, prediction_id: int, new_diseases: list
     return filtered
 
 
-
-
 #-------------- dÆ°á»›i Ä‘Ã¢y lÃ  nhá»«ng hÃ m Ä‘Æ°á»£c sá»­ dung cho viá»‡c chia theo controller khÃ´ng tÃ´t khÃ´ng lien máº¡ch bot gáº§n nhÆ° ko quyáº¿t Ä‘á»‹nh chÃ­nh xÃ¡c viá»‡c cáº§n thá»±c hiá»‡n --------------------------------------------------
 
 # Dá»± Ä‘oÃ¡n bá»‡nh dá»±a trÃªn list triá»‡u chá»©ng
diff --git a/KMS_ChatBot/Chatbot_BackEnd/utils/intent_utils.py b/KMS_ChatBot/Chatbot_BackEnd/utils/intent_utils.py
index 962c6a6..ca44ba9 100644
--- a/KMS_ChatBot/Chatbot_BackEnd/utils/intent_utils.py
+++ b/KMS_ChatBot/Chatbot_BackEnd/utils/intent_utils.py
@@ -73,12 +73,13 @@ def get_combined_schema_for_intent(intent: str) -> str:
 async def detect_intent(
     last_intent: str = None,
     recent_user_messages: list[str] = [],
-    recent_assistant_messages: list[str] = []
+    recent_assistant_messages: list[str] = [],
+    diagnosed_today: bool = False  # âœ… thÃªm dÃ²ng nÃ y
 ) -> str:
     # Sá»­ dá»¥ng trá»±c tiáº¿p message Ä‘Ã£ tÃ¡ch
     last_bot_msg = recent_assistant_messages[-1] if recent_assistant_messages else ""
     last_user_msg = recent_user_messages[-1] if recent_user_messages else ""
-
+    diagnosed_today_flag = "True" if diagnosed_today else "False"
     # logger.info(f"[Intent Debug] Recent User: {last_user_msg}")
     # logger.info(f"[Intent Debug] Recent Bot: {last_bot_msg}")
 
@@ -95,6 +96,8 @@ async def detect_intent(
 
         Valid intents: {", ".join(VALID_INTENTS)}
 
+        Diagnosed today: {diagnosed_today_flag}
+
         Instructions:
 
         - If the last intent was "symptom_query" and the user's current message clearly answers a previous follow-up (e.g., gives timing, severity, or symptom detail), then KEEP "symptom_query".
@@ -113,12 +116,18 @@ async def detect_intent(
         - If unsure, prefer a more specific intent over `"general_chat"`.
         - If the previous assistant message was a follow-up question about a symptom, and the user responds with something vague or approximate (e.g. â€œcháº¯c 5-10 phÃºtâ€, â€œkhoáº£ng sÃ¡ng tá»›i giá»â€, â€œtáº§m chiá»u hÃ´m quaâ€, "cháº¯c táº§m"), you SHOULD assume this is a continuation of the symptom discussion â†’ prefer "symptom_query".
         - If user says â€œkhÃ´ng biáº¿tâ€, â€œcháº¯c váº­yâ€, â€œkhÃ³ nÃ³iâ€, "khÃ´ng rÃµ", but itâ€™s still in reply to a symptom follow-up â†’ KEEP "symptom_query"
+        - If Diagnosed today = True and the user message sounds like explaining the cause or context of symptoms â†’ KEEP "symptom_query".
 
         Always return only ONE valid intent from the list.
         Do NOT explain your reasoning.
         Do NOT include any other words â€” only return the intent.
 
         Examples:
+        - Diagnosed today = True
+          User: "Ã  hÃ¬nh nhÆ° mÃ¬nh hiá»ƒu táº¡i sao mÃ¬nh cáº£m tháº¥y chá»‘ng máº·t rá»“i" â†’ âœ… â†’ intent = `symptom_query`
+          User: "cháº¯c lÃ  do hÃ´m qua mÃ¬nh Äƒn linh tinh" â†’ âœ… â†’ intent = `symptom_query`
+          User: "giá» mÃ¬nh má»›i nhá»› ra, hÃ´m qua bá»‹ trÃºng mÆ°a" â†’ âœ… â†’ intent = `symptom_query`
+          
         - Bot: â€œBáº¡n tháº¥y tÃª tay báº¯t Ä‘áº§u tá»« lÃºc nÃ o?â€  
           User: â€œnÃ³ tá»± nhiÃªn xuáº¥t hiá»‡n thÃ´iâ€ â†’ âœ… â†’ intent = `symptom_query`
 
diff --git a/KMS_ChatBot/Chatbot_BackEnd/utils/session_store.py b/KMS_ChatBot/Chatbot_BackEnd/utils/session_store.py
index 9e95925..9f6bfdb 100644
--- a/KMS_ChatBot/Chatbot_BackEnd/utils/session_store.py
+++ b/KMS_ChatBot/Chatbot_BackEnd/utils/session_store.py
@@ -1,22 +1,18 @@
-# session_store.py - RAM-only session store (táº¡m thá»i dÃ¹ng khi chÆ°a cÃ³ Redis)
-
-import asyncio
 import logging
 from collections import defaultdict
 import hashlib
 logger = logging.getLogger(__name__)
+import json
+from datetime import timedelta
+
+# Káº¿t ná»‘i Redis
+from redis import asyncio as aioredis
+redis_client = aioredis.Redis(host='localhost', port=6379, db=0, decode_responses=True)
 
 # ---------------------------
-# Cáº¤U HÃŒNH SESSION Táº M TRÃŠN RAM
+# CÃC HÃ€M LÃ€M VIá»†C Vá»šI session_dict (session_id)
 # ---------------------------
 
-def resolve_session_key(user_id: str = None, session_id: str = None) -> str:
-    """
-    Tráº£ vá» key dÃ¹ng trong session_dict vÃ  SYMPTOM_SESSION.
-    Æ¯u tiÃªn user_id náº¿u cÃ³, fallback session_id.
-    """
-    return str(user_id) if user_id else str(session_id)
-
 # Session lÆ°u theo session_id (giáº£ láº­p Redis)
 session_dict = {}
 
@@ -27,20 +23,37 @@ SYMPTOM_SESSION = defaultdict(list)
 SYMPTOM_KEY = "symptoms"         # Dáº¡ng list[str] -> chá»‰ lÆ°u ID hoáº·c tÃªn triá»‡u chá»©ng
 FOLLOWUP_KEY = "followup_asked"  # Dáº¡ng list[int] -> lÆ°u ID Ä‘Ã£ há»i follow-up
 
-# ---------------------------
-# CÃC HÃ€M LÃ€M VIá»†C Vá»šI session_dict (session_id)
-# ---------------------------
+# KhÃ³a máº·c Ä‘á»‹nh náº¿u khÃ´ng cÃ³ user/session
+def resolve_session_key(user_id: str = None, session_id: str = None) -> str:
+    if user_id is not None:
+        return f"session:user:{str(user_id)}"
+    if session_id is not None:
+        return f"session:sess:{str(session_id)}"
+    return "session:unknown"
 
-async def get_session_data(user_id: str = None, session_id: str = None) -> dict:
-    """Truy xuáº¥t dá»¯ liá»‡u session tá»« RAM."""
+
+# lÆ°u session
+async def save_session_data(user_id: str = None, session_id: str = None, data: dict = {}):
     key = resolve_session_key(user_id, session_id)
-    return session_dict.get(key, {})
 
+    # âš ï¸ Äá»c láº¡i session cÅ© náº¿u cÃ³
+    existing_raw = await redis_client.get(key)
+    existing_data = json.loads(existing_raw) if existing_raw else {}
+
+    # âœ… MERGE táº¡i Ä‘Ã¢y
+    existing_data.update(data)
 
-def save_session_data(user_id: str = None, session_id: str = None, data: dict = {}):
-    """LÆ°u dá»¯ liá»‡u session vÃ o RAM."""
+    # logger.info(f"ğŸ“ [SAVE] key = {key}")
+    # logger.info(f"ğŸ“ [SAVE] data = {json.dumps(existing_data, indent=2, ensure_ascii=False)}")
+    await redis_client.setex(key, timedelta(days=1), json.dumps(existing_data))
+
+
+# láº¥y session
+async def get_session_data(user_id: str = None, session_id: str = None) -> dict:
     key = resolve_session_key(user_id, session_id)
-    session_dict[key] = data
+    raw = await redis_client.get(key)
+    # logger.info(f"ğŸ“¤ [GET] key = {key}, raw = {raw}")
+    return json.loads(raw) if raw else {}
 
 # ----- Triá»‡u chá»©ng (ID dáº¡ng chuá»—i) -----
 
@@ -59,19 +72,18 @@ async def update_symptoms_in_session(session_id: str, new_symptoms: list[str]) -
         if s not in current:
             current.append(s)
     session[SYMPTOM_KEY] = current
-    save_session_data(session_id, session)
+    await save_session_data(session_id, session)
     return current
 
 async def clear_symptoms_in_session(session_id: str):
     """XÃ³a toÃ n bá»™ triá»‡u chá»©ng khá»i session."""
     session = await get_session_data(session_id)
     session[SYMPTOM_KEY] = []
-    save_session_data(session_id, session)
+    await save_session_data(session_id, session)
 
 # ----- Follow-up triá»‡u chá»©ng (ID dáº¡ng int) -----
 async def get_followed_up_symptom_ids(user_id: str = None, session_id: str = None) -> list[int]:
-    key = resolve_session_key(user_id, session_id)
-    session = await get_session_data(key)
+    session = await get_session_data(user_id=user_id, session_id=session_id)
     return session.get(FOLLOWUP_KEY, [])
 
 def hash_question(text: str) -> str:
@@ -82,25 +94,18 @@ async def get_followed_up_question_hashes(session_id: str) -> list[str]:
     return session.get(FOLLOWUP_KEY, [])
 
 async def mark_followup_asked(user_id: str = None, session_id: str = None, symptom_ids: list[int] = []):
-    key = resolve_session_key(user_id, session_id)
-    if not key:
-        return
-
-    session = await get_session_data(key)
+    session = await get_session_data(user_id=user_id, session_id=session_id)
     already = set(session.get(FOLLOWUP_KEY, []))
     already.update(symptom_ids)
     session[FOLLOWUP_KEY] = list(already)
-    save_session_data(key, session)
+    await save_session_data(user_id=user_id, session_id=session_id, data=session)
+
     # logger.info(f"âœ… [SessionStore] Ghi followup_asked vÃ o key: {key}")
 
 async def clear_followup_asked_all_keys(user_id: str = None, session_id: str = None):
-    key = resolve_session_key(user_id, session_id)
-    if not key:
-        return
-
-    session = await get_session_data(key)
+    session = await get_session_data(user_id=user_id, session_id=session_id)
     session[FOLLOWUP_KEY] = []
-    save_session_data(key, session)
+    await save_session_data(user_id=user_id, session_id=session_id, data=session)
     # logger.info(f"ğŸ§¹ [SessionStore] ÄÃ£ xoÃ¡ followup_asked cho key: {key}")
 
 
@@ -132,10 +137,10 @@ async def clear_symptoms_all_keys(user_id: str = None, session_id: str = None):
 
     SYMPTOM_SESSION.pop(key, None)
 
-    session = await get_session_data(key)
+    session = await get_session_data(user_id=user_id, session_id=session_id)
     session[SYMPTOM_KEY] = []
     session[FOLLOWUP_KEY] = []
-    save_session_data(key, session)
+    await save_session_data(user_id=user_id, session_id=session_id)
     # logger.info(f"ğŸ§¹ [SessionStore] ÄÃ£ xoÃ¡ SYMPTOM + followup cho key: {key}")
 
 # ---------------------------
@@ -144,23 +149,21 @@ async def clear_symptoms_all_keys(user_id: str = None, session_id: str = None):
 SYMPTOM_NOTE_KEY = "symptom_notes"
 
 async def update_symptom_note_in_session(user_id: str = None, session_id: str = None, symptom_name: str = "", note: str = ""):
-    session_key = resolve_session_key(user_id, session_id)
-    session = await get_session_data(session_key)
+    session = await get_session_data(user_id=user_id, session_id=session_id)
     notes = session.get(SYMPTOM_NOTE_KEY, {})
     notes[symptom_name] = note
     session[SYMPTOM_NOTE_KEY] = notes
-    save_session_data(session_key, session)
+    await save_session_data(user_id=user_id, session_id=session_id, data=session)
 
 async def get_symptom_notes_from_session(user_id: str = None, session_id: str = None) -> dict:
-    session_key = resolve_session_key(user_id, session_id)
-    session = await get_session_data(session_key)
+    session = await get_session_data(user_id=user_id, session_id=session_id)
     return session.get(SYMPTOM_NOTE_KEY, {})
 
 # ---------------------------
 # HÃ€M LÆ¯U TRá»® TIN NHáº®N
 # ---------------------------
 
-def update_chat_history_in_session(session_data, session_id, user_msg, bot_msg):
+async def update_chat_history_in_session(user_id, session_data, session_id, user_msg, bot_msg):
     recent_messages = session_data.get("recent_messages", [])
     recent_user_messages = session_data.get("recent_user_messages", [])
     recent_assistant_messages = session_data.get("recent_assistant_messages", [])
@@ -171,13 +174,14 @@ def update_chat_history_in_session(session_data, session_id, user_msg, bot_msg):
     recent_assistant_messages.append(bot_msg)
 
     # âœ¨ Loáº¡i bá» láº·p láº¡i liÃªn tiáº¿p
-    recent_user_messages = remove_consecutive_duplicates(recent_user_messages)
-    recent_assistant_messages = remove_consecutive_duplicates(recent_assistant_messages)
+    recent_user_messages = await remove_consecutive_duplicates(recent_user_messages)
+    recent_assistant_messages = await remove_consecutive_duplicates(recent_assistant_messages)
 
     session_data["recent_messages"] = recent_messages[-12:]
     session_data["recent_user_messages"] = recent_user_messages[-6:]
     session_data["recent_assistant_messages"] = recent_assistant_messages[-6:]
-    save_session_data(session_id, session_data)
+    await save_session_data(user_id=user_id, session_id=session_id, data=session_data)
+
     
 
     # logger.info("ğŸ§¾ recent_user_messages:")
@@ -188,8 +192,7 @@ def update_chat_history_in_session(session_data, session_id, user_msg, bot_msg):
     # for i, assistant_msg in enumerate(session_data["recent_assistant_messages"], 1):
     #     logger.info(f"ğŸ¤– [{i}] {assistant_msg}")
 
-
-def remove_consecutive_duplicates(messages: list[str]) -> list[str]:
+async def remove_consecutive_duplicates(messages: list[str]) -> list[str]:
     if not messages:
         return []
     result = [messages[0]]
@@ -197,3 +200,19 @@ def remove_consecutive_duplicates(messages: list[str]) -> list[str]:
         if msg != result[-1]:
             result.append(msg)
     return result
+
+# ---------------------------
+# ÄÃNH Dáº¤U ÄÃƒ Há»I TRIá»†U CHá»¨NG LIÃŠN QUAN (related_symptom_asked)
+# ---------------------------
+
+async def mark_related_symptom_asked(session_id: str = None, user_id: str = None):
+    session = await get_session_data(user_id=user_id, session_id=session_id)
+    session["related_symptom_asked"] = True
+    await save_session_data(user_id=user_id, session_id=session_id, data=session)
+
+
+async def reset_related_symptom_flag(session_id: str = None, user_id: str = None):
+    session = await get_session_data(user_id=user_id, session_id=session_id)
+    session["related_symptom_asked"] = False
+    await save_session_data(user_id=user_id, session_id=session_id, data=session)
+
diff --git a/KMS_ChatBot/Chatbot_BackEnd/utils/symptom_utils.py b/KMS_ChatBot/Chatbot_BackEnd/utils/symptom_utils.py
index 5ba5198..b8c07ed 100644
--- a/KMS_ChatBot/Chatbot_BackEnd/utils/symptom_utils.py
+++ b/KMS_ChatBot/Chatbot_BackEnd/utils/symptom_utils.py
@@ -78,7 +78,8 @@ def refresh_symptom_list():
     SYMPTOM_LIST = []
     load_symptom_list()
 
-def extract_symptoms_gpt(user_message, recent_messages, stored_symptoms_name=None, debug=False):
+def extract_symptoms_gpt(user_message, recent_messages, stored_symptoms_name=None, recent_assistant_messages=None, debug=False):
+
     symptom_lines = []
     name_to_symptom = {}
 
@@ -97,6 +98,10 @@ def extract_symptoms_gpt(user_message, recent_messages, stored_symptoms_name=Non
         for alias in aliases:
             name_to_symptom[normalize_text(alias)] = s
 
+    if recent_assistant_messages:
+        assistant_context = " ".join(recent_assistant_messages[-2:])
+    else:
+        assistant_context = "..."
 
     prompt = f"""
         You are a smart and careful medical assistant.
@@ -142,10 +147,16 @@ def extract_symptoms_gpt(user_message, recent_messages, stored_symptoms_name=Non
 
     ---
 
-    Conversation so far:
-    {user_message}
+    ğŸ§  Conversation context:
+    - The assistant just asked: "{assistant_context}"
+    - The user responded: "{user_message}"
+
+    âš ï¸ VERY IMPORTANT:
+    - Only extract symptoms mentioned in the **user's message**.
+    - Do **NOT** extract symptoms based on the assistant's question.
+    - The assistant message is provided only for context â€” not for extraction.
 
-    Now return a list of **symptom names** (from the list above) that the user is clearly experiencing.
+    Return a list of **symptom names** (from the list above) that the user is clearly experiencing.
 
     Only return names. Example: ["Má»‡t má»i", "Äau Ä‘áº§u"]
     """
@@ -184,41 +195,6 @@ def extract_symptoms_gpt(user_message, recent_messages, stored_symptoms_name=Non
             print("âŒ GPT symptom extraction failed:", str(e))
         return [], "Xin lá»—i, mÃ¬nh chÆ°a rÃµ báº¡n Ä‘ang cáº£m tháº¥y gÃ¬. Báº¡n cÃ³ thá»ƒ mÃ´ táº£ cá»¥ thá»ƒ hÆ¡n khÃ´ng?"
 
-# lÆ°u triá»‡u chá»©ng vÃ o database lÆ°u vÃ o user_symptom_history khi Ä‘ang thá»±c hiá»‡n cháº©n Ä‘oÃ¡n káº¿t quáº£
-def save_symptoms_to_db(user_id: int, symptoms: list[dict]) -> list[int]:
-    """
-    symptoms: list of dicts, each with:
-        - id: symptom_id
-        - note: optional note string (default empty)
-    """
-    conn = pymysql.connect(**DB_CONFIG)
-    saved_symptom_ids = []
-
-    try:
-        with conn.cursor() as cursor:
-            for symptom in symptoms:
-                symptom_id = symptom.get("id")
-                note = symptom.get("note", "")
-
-                if not symptom_id:
-                    continue
-
-                logger.info(f"â¡ï¸ LÆ°u symptom_id={symptom_id}, note={note}")
-
-                cursor.execute("""
-                    INSERT INTO user_symptom_history (user_id, symptom_id, record_date, notes)
-                    VALUES (%s, %s, %s, %s)
-                """, (user_id, symptom_id, date.today(), note))
-                
-                saved_symptom_ids.append(symptom_id)
-
-        conn.commit()
-    finally:
-        conn.close()
-
-    return saved_symptom_ids
-
-
 # Táº¡o cÃ¢u há»i tiáº¿p theo nháº¹ nhÃ ng, thÃ¢n thiá»‡n, gá»£i Ã½ ngÆ°á»i dÃ¹ng chia sáº» thÃªm thÃ´ng tin dá»±a trÃªn cÃ¡c triá»‡u chá»©ng Ä‘Ã£ ghi nháº­n.
 def join_symptom_names_vietnamese(names: list[str]) -> str:
     if not names:
@@ -465,51 +441,119 @@ def has_diagnosis_today(user_id: int) -> bool:
         conn.close()
 
 # HÃ m táº¡o ghi chÃº cho triá»‡u chá»©ng khi thÃªm vÃ o database
-async def generate_symptom_note(symptoms: list[dict], recent_messages: list[str]) -> list[dict]:
+async def generate_symptom_note(
+    symptoms: list[dict],
+    recent_messages: list[str],
+    existing_notes: list[dict] = None
+) -> list[dict]:
     symptom_lines = "\n".join(f"- {s['name']}" for s in symptoms)
-    context = "\n".join(f"- {msg}" for msg in recent_messages[-6:])
+    context = "\n".join(f"- {msg}" for msg in recent_messages[-2:])
+
+    # Build existing note text if provided
+    existing_notes_text = ""
+    if existing_notes:
+        existing_notes_text = "\n".join(f"- {n['name']}: {n['note']}" for n in existing_notes)
 
     prompt = f"""
-    You are a helpful assistant supporting health documentation.
+        You are a helpful assistant supporting health documentation.
+
+        Below is a list of symptoms the user may be experiencing â€” but they may not have described all of them yet.
+
+        Your task is:
+        ğŸ‘‰ Only create a note for a symptom if the user clearly mentioned or described it in the recent conversation.
+        ğŸ‘‰ If the user added new detail for a symptom that already has a note, you MUST override and rewrite the note with updated info.
+
+        ğŸ’¬ Recent conversation:
+        {context}
+
+        ğŸ“Œ List of possible symptoms:
+        {symptom_lines}
+
+        ğŸ“„ Existing notes (if any):
+        {existing_notes_text or "None"}
+
+        âš ï¸ Output instructions:
+        - Return a JSON list, each item must have `id`, `name`, and `note`.
+        - Only include symptoms mentioned in the current conversation.
+        - For existing notes: only update if there is **new information**.
+        - Do NOT return notes for symptoms that are not clearly referenced.
+
+        âœ… Example output:
+        ```json
+        [
+        {{
+            "id": 1,
+            "name": "Äau Ä‘áº§u",
+            "note": "NgÆ°á»i dÃ¹ng bá»‹ Ä‘au Ä‘áº§u ngay sau khi ngá»§ dáº­y vÃ  nÃ³i ráº±ng cÆ¡n Ä‘au kÃ©o dÃ i hÆ¡n 4 tiáº¿ng."
+        }}
+        ]
+""".strip()
+    try:
+        # Gá»i GPT (khÃ´ng dÃ¹ng await vÃ¬ Ä‘Ã¢y lÃ  hÃ m sync)
+        response = chat_completion(
+            [{"role": "user", "content": prompt}],
+            temperature=0.4,
+            max_tokens=400
+        )
+
+        content = response.choices[0].message.content if response.choices else ""
+        # logger.info(f"ğŸ“¤ GPT symptom note raw repr:\n{response.choices[0].message.content if response.choices else ""}")
 
-    Below is a conversation with a user and a list of symptoms they mentioned.
+        # Clean markdown block if any
+        if content.startswith("```json"):
+            content = content.replace("```json", "").replace("```", "").strip()
 
-    ğŸ’¬ Recent conversation:
-    {context}
+        parsed = json.loads(content)
 
-    ğŸ§  List of symptoms:
-    {symptom_lines}
+        # Validate format
+        if not isinstance(parsed, list):
+            raise ValueError("GPT returned non-list")
 
-    ğŸ‘‰ Your task:
-    For each symptom, write a short, natural note in Vietnamese summarizing what the user said about it â€” including any details like timing, severity, or triggers if available.
+        for item in parsed:
+            if not all(k in item for k in ["id", "name", "note"]):
+                raise ValueError("Missing fields in GPT output")
 
-    âš ï¸ Instructions:
-    - You must return a list of JSON objects with `name` and `note` fields.
-    - Do NOT invent symptoms not mentioned.
-    - If thereâ€™s no clear info about a symptom, write a generic note.
-    - Do not include explanations, just the raw JSON.
+        return parsed
 
-    Example output:
-    ```json
-    [
-      {{
-        "name": "Äau Ä‘áº§u",
-        "note": "NgÆ°á»i dÃ¹ng cáº£m tháº¥y Ä‘au Ä‘áº§u xuáº¥t hiá»‡n khi má»›i ngá»§ dáº­y."
-      }},
-      ...
-    ]
-    ```
-    """.strip()
+    except Exception as e:
+        logger.warning(f"âš ï¸ GPT fallback (note): {e}")
+        return [{"name": s["name"], "note": "NgÆ°á»i dÃ¹ng Ä‘Ã£ mÃ´ táº£ má»™t sá»‘ triá»‡u chá»©ng trong cuá»™c trÃ² chuyá»‡n."} for s in symptoms]
+
+
+# lÆ°u triá»‡u chá»©ng vÃ o database lÆ°u vÃ o user_symptom_history khi Ä‘ang thá»±c hiá»‡n cháº©n Ä‘oÃ¡n káº¿t quáº£
+def save_symptoms_to_db(user_id: int, symptoms: list[dict]) -> list[int]:
+    """
+    symptoms: list of dicts, each with:
+        - id: symptom_id
+        - note: optional note string (default empty)
+    """
+    conn = pymysql.connect(**DB_CONFIG)
+    saved_symptom_ids = []
 
     try:
-        response = await chat_completion([
-            {"role": "user", "content": prompt}
-        ], temperature=0.4, max_tokens=400)
+        with conn.cursor() as cursor:
+            for symptom in symptoms:
+                symptom_id = symptom.get("id")
+                note = symptom.get("note", "")
+
+                if not symptom_id:
+                    continue
+
+                # logger.info(f"â¡ï¸ LÆ°u symptom_id={symptom_id}, note={note}")
+
+                cursor.execute("""
+                    INSERT INTO user_symptom_history (user_id, symptom_id, record_date, notes)
+                    VALUES (%s, %s, %s, %s)
+                """, (user_id, symptom_id, date.today(), note))
+                
+                saved_symptom_ids.append(symptom_id)
+
+        conn.commit()
+    finally:
+        conn.close()
+
+    return saved_symptom_ids
 
-        return json.loads(response.choices[0].message.content.strip())
-    except Exception:
-        # fallback náº¿u lá»—i GPT
-        return [{"name": s["name"], "note": "NgÆ°á»i dÃ¹ng Ä‘Ã£ mÃ´ táº£ má»™t sá»‘ triá»‡u chá»©ng trong cuá»™c trÃ² chuyá»‡n."} for s in symptoms]
 
 def update_symptom_note(user_id: int, symptom_name: str, user_message: str) -> bool:
     today = datetime.now().date().isoformat()
diff --git a/KMS_ChatBot/requirements.txt b/KMS_ChatBot/requirements.txt
index 99bff58..94df55d 100644
--- a/KMS_ChatBot/requirements.txt
+++ b/KMS_ChatBot/requirements.txt
@@ -7,4 +7,5 @@ rapidfuzz==3.13.0
 Requests==2.32.4
 tiktoken==0.9.0
 Unidecode==1.4.0
-Uvicorn-0.34.3
\ No newline at end of file
+Uvicorn-0.34.3
+redis
\ No newline at end of file
